{-# LANGUAGE OverloadedStrings #-}
module Hayoo.Indexer.Hoogle.Parse
  ( Package (..)
  , parse

  -- This is just exported for testing purposes!
  -- should probably be put into a module "internal"
  , hoogle
  , modules
  , declInfo
  , preamble
  , moduleInfo
  , functionInfo
  , typeInfo
  , dataInfo
  ) where


import           Control.Applicative  ((<|>))
import qualified Control.Applicative  as A
import qualified Data.Maybe           as Maybe
import           Data.Semigroup       ((<>))
import qualified Data.Text            as T
import qualified Data.Void            as Void
import           Hayoo.Core.DeclInfo  (DeclInfo (..))
import qualified Hayoo.Core.DeclInfo  as DeclInfo
import qualified Text.Megaparsec      as M
import qualified Text.Megaparsec.Char as M



-- PARSE HOOGLE FORMAT


type Parser
  = M.Parsec Void.Void T.Text


type ModuleInfo
  = DeclInfo


data Package
  = Package
    { _comment :: Maybe T.Text
    , _name    :: T.Text        -- | e.g. @package servant
    , _version :: T.Text        -- | e.g. @version 0.12
    } deriving (Show, Eq)


parse :: T.Text -> Either (M.ParseError Char Void.Void) (Package, [DeclInfo])
parse =
  M.parse hoogle ""



-- URI HELPERS


hackageUri :: T.Text
hackageUri =
  "http://hackage.haskell.org/package"


packageUri :: Package -> T.Text
packageUri pkg =
  hackageUri </> (_name pkg)


moduleUri :: Package -> T.Text -> T.Text
moduleUri pkg modName =
  packageUri pkg </> "docs" </> (T.replace "." "-" modName <> ".html")


functionUri :: ModuleInfo -> T.Text -> T.Text
functionUri modInfo name =
  docURI modInfo <> "#v:" <> name


typeUri :: ModuleInfo -> T.Text -> T.Text
typeUri modInfo name =
  docURI modInfo <> "#t:" <> name



-- CHAR HELPERS


isEndOfLine :: Char -> Bool
isEndOfLine c =
  c == '\n' || c == '\r'



-- PARSING


hoogle :: Parser (Package, [DeclInfo])
hoogle = do
  pkg        <- preamble
  allModules <- A.many (M.space >> modules pkg)
  pure (pkg, mconcat allModules)


modules :: Package -> Parser [DeclInfo]
modules pkg = do
  modInfo   <- moduleInfo pkg
  let lookAheadModule = M.lookAhead (M.try (M.space >> moduleInfo pkg >> pure ()) <|> M.eof)
  declInfos <- M.manyTill (M.space >> declInfo modInfo) lookAheadModule
  pure (modInfo:Maybe.catMaybes declInfos)


declInfo :: ModuleInfo -> Parser (Maybe DeclInfo)
declInfo modInfo =
  M.try (Just <$> typeInfo modInfo)
    <|> M.try (Just <$> dataInfo modInfo)
    <|> M.try (Just <$> newtypeInfo modInfo)
    <|> M.try (classInfo modInfo >> pure Nothing)
    <|> M.try (instanceInfo modInfo >> pure Nothing)
    <|> M.try (infixInfo modInfo >> pure Nothing)
    <|> M.try (typeFamilyInfo modInfo >> pure Nothing)
    <|> M.try (ignoreBrace modInfo >> pure Nothing)
    <|> M.try (Just <$> functionInfo modInfo)


preamble :: Parser Package
preamble = do
  -- Skip the first few lines. They always look like the following:
  -- "-- Hoogle documentation, generated by Haddock\n
  --  -- See Hoogle, http://www.haskell.org/hoogle\n\n\n"
  line >> line >> M.space
  comment     <- A.optional docComment
  packageName <- M.string "@package " >> line
  version     <- M.string "@version " >> line
  pure (Package comment packageName version)


moduleInfo :: Package -> Parser DeclInfo
moduleInfo pkg = do
  comment <- A.optional (M.try docComment)
  modName <- M.string "module " >> line
  pure $
    DeclInfo
      { moduleName = modName
      , signature  = ""                          -- No signature for a module
      , package    = (_name pkg)
      , sourceURI  = ""
      , declDescr  = comment
      , declType   = DeclInfo.Module
      , docURI     = moduleUri pkg modName
      }


functionInfo :: ModuleInfo -> Parser DeclInfo
functionInfo modInfo = do
  comment <- A.optional (M.try docComment)
  fnName  <- ident <* M.space <* M.string ":: "
  sig     <- M.space >> line
  pure $
    DeclInfo
      { moduleName = moduleName modInfo
      , signature  = sig
      , package    = package modInfo
      , sourceURI  = ""
      , declDescr  = comment
      , declType   = DeclInfo.Function
      , docURI     = functionUri modInfo fnName
      }


typeInfo :: ModuleInfo -> Parser DeclInfo
typeInfo modInfo = do
  comment  <- A.optional (M.try docComment)
  typeName <- M.string "type " >> ident -- TODO: Check whether this works
  _lhs     <- M.takeWhileP (Just "left hand side") (/= '=')
  sig      <- M.char '=' >> line
  pure $
    DeclInfo
      { moduleName = moduleName modInfo
      , signature  = sig
      , package    = package modInfo
      , sourceURI  = ""
      , declDescr  = comment
      , declType   = DeclInfo.Type
      , docURI     = typeUri modInfo typeName
      }


newtypeInfo :: ModuleInfo -> Parser DeclInfo
newtypeInfo modInfo = do
  comment     <- A.optional (M.try docComment)
  _           <- M.string "newtype "
  _constraint <- A.optional (M.try (M.manyTill M.anyChar (M.try (M.string " =>"))))
  typeName    <- ident -- TODO: Check whether this works for operators as well
  _params     <- line
  pure $
    DeclInfo
      { moduleName = moduleName modInfo
      , signature  = ""
      , package    = package modInfo
      , sourceURI  = ""
      , declDescr  = comment
      , declType   = DeclInfo.Newtype
      , docURI     = typeUri modInfo typeName
      }


dataInfo :: ModuleInfo -> Parser DeclInfo
dataInfo modInfo = do
  comment <- A.optional (M.try docComment)
  _       <- M.string "data "
  dName   <- ident
  _sig    <- line
  pure $
    DeclInfo
      { moduleName = moduleName modInfo
      , signature  = ""
      , package    = package modInfo
      , sourceURI  = ""
      , declDescr  = comment
      , declType   = DeclInfo.Data
      , docURI     = typeUri modInfo dName
      }


instanceInfo :: ModuleInfo -> Parser ()
instanceInfo _modInfo = do
  _ <- A.optional (M.try docComment)
  _ <- M.string "instance "
  line >> pure ()


classInfo :: ModuleInfo -> Parser ()
classInfo _modInfo = do
  _ <- A.optional (M.try docComment)
  _ <- M.string "class "
  line >> pure ()


infixInfo :: ModuleInfo -> Parser ()
infixInfo _modInfo = do
  (M.string "infixr" <|> M.string "infixl" <|> M.string "infix") >> line >> pure ()


typeFamilyInfo :: ModuleInfo -> Parser ()
typeFamilyInfo _modInfo = do
  _ <- M.space >> M.string "type family "
  _ <- ident -- Not sure, whether we should do this
  line >> pure ()


ignoreBrace :: ModuleInfo -> Parser ()
ignoreBrace _ =
  M.space >> (M.char '{' <|> M.char '}') >> line >> pure ()



-- COMMENT PARSERS


docComment :: Parser T.Text
docComment = do
  firstLine <- M.string "-- | " >> line
  result    <- M.many (M.try (M.space >> M.string "--" >> (fmap T.stripStart line)))
  pure (T.intercalate "\n" (firstLine:result))



-- MISCELLANEOUS PARSER


ident :: Parser T.Text
ident =
  M.takeWhileP (Just "identifier") (\c -> c /= ' ' && not (isEndOfLine c))


line :: Parser T.Text
line =
  M.takeWhileP (Just "line") (not . isEndOfLine)
    <* (M.try M.eol <|> M.try (M.eof >> pure "") <|> pure "")



-- HELPERS


(</>) :: T.Text -> T.Text -> T.Text
(</>) a b =
  a <> "/" <> b
